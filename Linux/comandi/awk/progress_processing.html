<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="markdown-it" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
        <meta name="author" content="runner" />
        <meta name="dcterms.date" content="2025-04-08 13:44:53.617" />
        <title>progress_processing</title>
        <style type="text/css">
            code {
                white-space: pre-wrap;
            }
            span.smallcaps {
                font-variant: small-caps;
            }
            span.underline {
                text-decoration: underline;
            }
            div.column {
                display: inline-block;
                vertical-align: top;
                width: 50%;
            }
        </style>
        <style type="text/css">
            a.sourceLine {
                display: inline-block;
                line-height: 1.25;
            }
            a.sourceLine {
                pointer-events: none;
                color: inherit;
                text-decoration: inherit;
            }
            a.sourceLine:empty {
                height: 1.2em;
            }
            .sourceCode {
                overflow: visible;
            }
            code.sourceCode {
                white-space: pre;
                position: relative;
            }
            div.sourceCode {
                margin: 1em 0;
            }
            pre.sourceCode {
                margin: 0;
            }
            @media screen {
                div.sourceCode {
                    overflow: auto;
                }
            }
            @media print {
                code.sourceCode {
                    white-space: pre-wrap;
                }
                a.sourceLine {
                    text-indent: -1em;
                    padding-left: 1em;
                }
            }
            pre.numberSource a.sourceLine {
                position: relative;
                left: -4em;
            }
            pre.numberSource a.sourceLine::before {
                content: attr(title);
                position: relative;
                left: -1em;
                text-align: right;
                vertical-align: baseline;
                border: none;
                pointer-events: all;
                display: inline-block;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                padding: 0 4px;
                width: 4em;
                background-color: #ffffff;
                color: #a0a0a0;
            }
            pre.numberSource {
                margin-left: 3em;
                border-left: 1px solid #a0a0a0;
                padding-left: 4px;
            }
            div.sourceCode {
                color: #1f1c1b;
                background-color: #ffffff;
            }
            @media screen {
                a.sourceLine::before {
                    text-decoration: underline;
                }
            }
            code span {
                color: #1f1c1b;
            } /* Normal */
            code span.al {
                color: #bf0303;
                background-color: #f7e6e6;
                font-weight: bold;
            } /* Alert */
            code span.an {
                color: #ca60ca;
            } /* Annotation */
            code span.at {
                color: #0057ae;
            } /* Attribute */
            code span.bn {
                color: #b08000;
            } /* BaseN */
            code span.bu {
                color: #644a9b;
                font-weight: bold;
            } /* BuiltIn */
            code span.cf {
                color: #1f1c1b;
                font-weight: bold;
            } /* ControlFlow */
            code span.ch {
                color: #924c9d;
            } /* Char */
            code span.cn {
                color: #aa5500;
            } /* Constant */
            code span.co {
                color: #898887;
            } /* Comment */
            code span.cv {
                color: #0095ff;
            } /* CommentVar */
            code span.do {
                color: #607880;
            } /* Documentation */
            code span.dt {
                color: #0057ae;
            } /* DataType */
            code span.dv {
                color: #b08000;
            } /* DecVal */
            code span.er {
                color: #bf0303;
                text-decoration: underline;
            } /* Error */
            code span.ex {
                color: #0095ff;
                font-weight: bold;
            } /* Extension */
            code span.fl {
                color: #b08000;
            } /* Float */
            code span.fu {
                color: #644a9b;
            } /* Function */
            code span.im {
                color: #ff5500;
            } /* Import */
            code span.in {
                color: #b08000;
            } /* Information */
            code span.kw {
                color: #1f1c1b;
                font-weight: bold;
            } /* Keyword */
            code span.op {
                color: #1f1c1b;
            } /* Operator */
            code span.ot {
                color: #006e28;
            } /* Other */
            code span.pp {
                color: #006e28;
            } /* Preprocessor */
            code span.re {
                color: #0057ae;
                background-color: #e0e9f8;
            } /* RegionMarker */
            code span.sc {
                color: #3daee9;
            } /* SpecialChar */
            code span.ss {
                color: #ff5500;
            } /* SpecialString */
            code span.st {
                color: #bf0303;
            } /* String */
            code span.va {
                color: #0057ae;
            } /* Variable */
            code span.vs {
                color: #bf0303;
            } /* VerbatimString */
            code span.wa {
                color: #bf0303;
            } /* Warning */
        </style>
        <!--
  Firefox non carica font da locale quindi il font può non essere visibile
  quando di carica la pagina da locale.
  Bisogna impostare about:config
    security.fileuri.strict_origin_policy = false
  -->
        <link rel="stylesheet" href="../../../inc/css/katex.min.css" />
        <link rel="stylesheet" href="../../../inc/css/fonts/google_fonts.css" />
        <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous"> -->
        <link rel="stylesheet" href="../../../inc/css/bootstrap.min.css" />
        <link rel="stylesheet" href="../../../inc/css/cdp.css" />
        <!--[if lt IE 9]>
            <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
        <![endif]-->
        <meta name="keywords" content="Appunti,Note" />
        <meta name="description" content="Appunti di runner" />
        <link rel="icon" type="image/x-icon" href="../../../inc/img/favicon.ico" />
        <link rel="shortcut icon" type="image/x-icon" href="../../../inc/img/favicon.ico" />

        <link rel="stylesheet" href="../../../inc/js/hljs/styles/default.css" />
        <script src="../../../inc/js/hljs/lib/highlight.js"></script>
        <script src="../../../inc/js/bootstrap/bootstrap.bundle.min.js"></script>
        <!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script> -->
        <script>
            hljs.initHighlightingOnLoad();
        </script>
        <script type="module">
            import mermaid from '../../../inc/js/mermaid/dist/mermaid.esm.min.mjs';
            // import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
            mermaid.initialize({ startOnLoad: true });
        </script>
    </head>
    <body></body>
</html>
<h1 id="progress_processing" tabindex="-1">progress_processing <a class="header-anchor" href="#progress_processing" aria-hidden="true">🔗</a></h1>
<p class="code">2025-04-08 13:44:53.617</p>
<nav class="table-of-contents"><ol><li><a href="#awk-text-processing">Awk text processing </a></li><li><a href="#progress-bars-processing-with-awk-(and-stdbuf)">Progress bars processing with awk (and stdbuf) </a><ol><li><a href="#processing-single-line-progress-outputs">Processing single-line progress outputs </a></li><li><a href="#working-around-the-buffering">Working around the buffering </a></li><li><a href="#streams-processing">Streams processing </a></li><li><a href="#putting-things-together">Putting things together </a></li></ol></li></ol></nav><h1 id="esempio-di-processamento-di-progress-bar-testuali" tabindex="-1">Esempio di processamento di progress bar testuali <a class="header-anchor" href="#esempio-di-processamento-di-progress-bar-testuali" aria-hidden="true">🔗</a></h1>
<h2 id="awk-text-processing" tabindex="-1">Awk text processing <a class="header-anchor" href="#awk-text-processing" aria-hidden="true">🔗</a></h2>
<p>Awk’s most common usage is to print single tokens of a line:</p>
<pre><code class="language-awk">$ echo A BC DEF | awk <span class="hljs-string">&#x27;{print $2}&#x27;</span>
BC

$ echo A BC DEF | awk <span class="hljs-string">&#x27;{print $NF}&#x27;</span>         <span class="hljs-comment"># print the last token</span>
DEF

$ echo A BC DEF | awk <span class="hljs-string">&#x27;{print $1 &quot;/&quot; $2 }&#x27;</span>  <span class="hljs-comment"># print other strings</span>
A/BC
</code></pre>
<p>We can specify other delimiters:</p>
<pre><code class="language-awk">$ echo A:BC:DEF | awk -F: <span class="hljs-string">&#x27;{print $2}&#x27;</span>
BC
</code></pre>
<p>We can also perform (printf-style) formatting and operations:</p>
<pre><code class="language-awk">$ echo <span class="hljs-string">&quot;100
&gt; 200&quot;</span> | awk <span class="hljs-string">&#x27;{printf &quot;%i\n&quot;, $1 / 4}&#x27;</span>
<span class="hljs-number">25</span>
<span class="hljs-number">50</span>
</code></pre>
<p>This is the awk way of printing a token of matching lines:</p>
<pre><code class="language-awk">$ echo <span class="hljs-string">&quot;I love pizza
&gt; I love Commodore64
&gt; I dislike seafood&quot;</span> | awk <span class="hljs-string">&#x27;/love/ {print $3}&#x27;</span>
pizza
Commodore <span class="hljs-number">64</span>
</code></pre>
<p>Note that, while more compact than Perl, we can’t print a capturing group (in fact, we use a single word for Commodore64).</p>
<h2 id="progress-bars-processing-with-awk-(and-stdbuf)" tabindex="-1">Progress bars processing with awk (and stdbuf) <a class="header-anchor" href="#progress-bars-processing-with-awk-(and-stdbuf)" aria-hidden="true">🔗</a></h2>
<p>Sometimes, we want to process progress bars. Although this may seem masochistic, there is actually a legitimate case, and it’s to process the output to send it to a separate program for displaying in a different way.</p>
<p>Suppose you want to display the <code>dd</code> progress in a nice window.</p>
<p>The <code>whiptail</code> program can display fancy [for terminal people] text windows; with a certain configuration, it takes numbers in stdin, representing the percentage of completion.
For simplicity, in this section we just perform the text processing, so that we transform the dd output into a sequence of progress numbers.</p>
<p>This is a sample of <code>dd</code> progress:</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero status=progress of=/dev/null
3573420032 bytes (3,6 GB, 3,3 GiB) copied, 2 s, 1,8 GB/s
</code></pre>
<p>There are a few problems to know:</p>
<ul>
<li>dd displays the progress on a single line, by cyclically overwriting the existing text; since it never prints a new line, <strong>how do we capture each individual cycle output</strong>?</li>
<li>severe hair pulling warning: <strong>pipe streams are buffered</strong>; single characters will not be piped until a certain amount is pushed (or the EOF is reached)</li>
<li>how to process the streams, and which ones?</li>
</ul>
<h3 id="processing-single-line-progress-outputs" tabindex="-1">Processing single-line progress outputs <a class="header-anchor" href="#processing-single-line-progress-outputs" aria-hidden="true">🔗</a></h3>
<p>First, we need to detail the problem.</p>
<p>From a technical perspective, single-line progress outputs are accomplished by using the <strong>“carriage return character”</strong> (<mark><strong><code>\r</code></strong></mark>), which returns to the beginning of the line.</p>
<p>So, now we know what to do: <strong>to tell awk to process the string received once it gets a <code>\r</code> (rather than waiting for a newline <code>\n</code>)</strong>.</p>
<p>Regarding the how, the record separator variable comes to the rescue.</p>
<p>In awk, the <strong>record separator</strong> is represented by the variable <code>RS</code>; we set it using the <code>-v</code> option:</p>
<pre><code class="language-awk">$ awk -v RS=<span class="hljs-string">&#x27;\r&#x27;</span> <span class="hljs-string">&#x27;&lt;mycommand&gt;&#x27;</span>
</code></pre>
<h3 id="working-around-the-buffering" tabindex="-1">Working around the buffering <a class="header-anchor" href="#working-around-the-buffering" aria-hidden="true">🔗</a></h3>
<p>For the pipe buffering problem, we use a tool called <code>stdbuf</code>:</p>
<pre><code class="language-bash">$ program_with_tiny_outputs | <span class="hljs-built_in">stdbuf</span> -o0 text_processing_program
</code></pre>
<p>The <code>-o0</code> simply tells to adjust the output to use a <code>0 bytes buffer</code>, that is, <strong>no buffering</strong>.</p>
<h3 id="streams-processing" tabindex="-1">Streams processing <a class="header-anchor" href="#streams-processing" aria-hidden="true">🔗</a></h3>
<p>dd will use two streams:</p>
<ul>
<li><code>stdout</code>, for sending the data</li>
<li><code>stderr</code>, for displaying the progress</li>
</ul>
<p>Text processing programs receive data in their stdin from the outputting program’s stdout.</p>
<p>So we need to find how to:</p>
<ul>
<li>take the dd <code>stdout</code> output and direct it to a <code>file</code></li>
<li>take the dd <code>stderr</code> output, convert it to a <code>stdout</code></li>
<li>send the last <code>stdout</code> mentioned to the <code>stdin</code> of awk</li>
</ul>
<p>This is the pattern:</p>
<pre><code class="language-bash">$ (<span class="hljs-built_in">dd</span> status=progress <span class="hljs-keyword">if</span>=/dev/zero bs=1G count=100 &gt; /dev/null) 2&gt;&amp;1 | awk <span class="hljs-string">&#x27;&lt;mycommand&gt;&#x27;</span>
<span class="hljs-comment"># oppure</span>
$ (<span class="hljs-built_in">dd</span> status=progress <span class="hljs-keyword">if</span>=/dev/zero bs=1G count=100 of=/dev/null) 2&gt;&amp;1 | awk <span class="hljs-string">&#x27;&lt;mycommand&gt;&#x27;</span>
</code></pre>
<p>The crux is <code>2&gt;&amp;1</code>. What this does is to redirect <code>stderr (stream 2)</code> to <code>stdout (stream 1)</code>.</p>
<p>Now, the question is, won’t we mix dd’s stdout and stderr into stdout?</p>
<p>Nope! This is because from this group:</p>
<pre><code class="language-bash">(<span class="hljs-built_in">dd</span> status=progress <span class="hljs-keyword">if</span>=/dev/zero bs=1G count=100 &gt; /dev/null)
</code></pre>
<p>there is not stdout output, because it’s sent to <code>/dev/null</code>.
Ovvero la subshell non produce stdout perchè dd lo invia tutto al file di output.</p>
<h3 id="putting-things-together" tabindex="-1">Putting things together <a class="header-anchor" href="#putting-things-together" aria-hidden="true">🔗</a></h3>
<p>Although the statement looks ugly, it makes sense with the understanding of the above concepts:</p>
<pre><code class="language-bash">$ (<span class="hljs-built_in">dd</span> status=progress <span class="hljs-keyword">if</span>=/dev/zero bs=1GB count=100 &gt; /dev/null) 2&gt;&amp;1 | <span class="hljs-built_in">stdbuf</span> -o0 awk -v RS=<span class="hljs-string">&#x27;\r&#x27;</span> <span class="hljs-string">&#x27;/copied/ { printf &quot;%i\n&quot;, $1 / 1000000000 }&#x27;</span>
10
22
35
47
59
71
83
96
</code></pre>
<p>The only minor additional detail is that we need to filter in the lines including ‘copied’; dd also output other ones, which we want to discard.</p>
<pre><code class="language-bash">$ (<span class="hljs-built_in">dd</span> status=progress <span class="hljs-keyword">if</span>=/dev/zero bs=1GB count=100 of=/dev/null) 2&gt;&amp;1 | <span class="hljs-built_in">stdbuf</span> -o0 awk -v RS=<span class="hljs-string">&#x27;\r&#x27;</span> <span class="hljs-string">&#x27;/copied/ { printf &quot;%i\n&quot;, $1 / 1000000000 }&#x27;</span>
</code></pre>
</body></html>