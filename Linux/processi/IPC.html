<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
    <head>
        <meta charset="utf-8" />
        <meta name="generator" content="markdown-it" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
        <meta name="author" content="runner" />
        <meta name="dcterms.date" content="2025-04-08 13:38:19.894" />
        <title>IPC</title>
        <style type="text/css">
            code {
                white-space: pre-wrap;
            }
            span.smallcaps {
                font-variant: small-caps;
            }
            span.underline {
                text-decoration: underline;
            }
            div.column {
                display: inline-block;
                vertical-align: top;
                width: 50%;
            }
        </style>
        <style type="text/css">
            a.sourceLine {
                display: inline-block;
                line-height: 1.25;
            }
            a.sourceLine {
                pointer-events: none;
                color: inherit;
                text-decoration: inherit;
            }
            a.sourceLine:empty {
                height: 1.2em;
            }
            .sourceCode {
                overflow: visible;
            }
            code.sourceCode {
                white-space: pre;
                position: relative;
            }
            div.sourceCode {
                margin: 1em 0;
            }
            pre.sourceCode {
                margin: 0;
            }
            @media screen {
                div.sourceCode {
                    overflow: auto;
                }
            }
            @media print {
                code.sourceCode {
                    white-space: pre-wrap;
                }
                a.sourceLine {
                    text-indent: -1em;
                    padding-left: 1em;
                }
            }
            pre.numberSource a.sourceLine {
                position: relative;
                left: -4em;
            }
            pre.numberSource a.sourceLine::before {
                content: attr(title);
                position: relative;
                left: -1em;
                text-align: right;
                vertical-align: baseline;
                border: none;
                pointer-events: all;
                display: inline-block;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
                padding: 0 4px;
                width: 4em;
                background-color: #ffffff;
                color: #a0a0a0;
            }
            pre.numberSource {
                margin-left: 3em;
                border-left: 1px solid #a0a0a0;
                padding-left: 4px;
            }
            div.sourceCode {
                color: #1f1c1b;
                background-color: #ffffff;
            }
            @media screen {
                a.sourceLine::before {
                    text-decoration: underline;
                }
            }
            code span {
                color: #1f1c1b;
            } /* Normal */
            code span.al {
                color: #bf0303;
                background-color: #f7e6e6;
                font-weight: bold;
            } /* Alert */
            code span.an {
                color: #ca60ca;
            } /* Annotation */
            code span.at {
                color: #0057ae;
            } /* Attribute */
            code span.bn {
                color: #b08000;
            } /* BaseN */
            code span.bu {
                color: #644a9b;
                font-weight: bold;
            } /* BuiltIn */
            code span.cf {
                color: #1f1c1b;
                font-weight: bold;
            } /* ControlFlow */
            code span.ch {
                color: #924c9d;
            } /* Char */
            code span.cn {
                color: #aa5500;
            } /* Constant */
            code span.co {
                color: #898887;
            } /* Comment */
            code span.cv {
                color: #0095ff;
            } /* CommentVar */
            code span.do {
                color: #607880;
            } /* Documentation */
            code span.dt {
                color: #0057ae;
            } /* DataType */
            code span.dv {
                color: #b08000;
            } /* DecVal */
            code span.er {
                color: #bf0303;
                text-decoration: underline;
            } /* Error */
            code span.ex {
                color: #0095ff;
                font-weight: bold;
            } /* Extension */
            code span.fl {
                color: #b08000;
            } /* Float */
            code span.fu {
                color: #644a9b;
            } /* Function */
            code span.im {
                color: #ff5500;
            } /* Import */
            code span.in {
                color: #b08000;
            } /* Information */
            code span.kw {
                color: #1f1c1b;
                font-weight: bold;
            } /* Keyword */
            code span.op {
                color: #1f1c1b;
            } /* Operator */
            code span.ot {
                color: #006e28;
            } /* Other */
            code span.pp {
                color: #006e28;
            } /* Preprocessor */
            code span.re {
                color: #0057ae;
                background-color: #e0e9f8;
            } /* RegionMarker */
            code span.sc {
                color: #3daee9;
            } /* SpecialChar */
            code span.ss {
                color: #ff5500;
            } /* SpecialString */
            code span.st {
                color: #bf0303;
            } /* String */
            code span.va {
                color: #0057ae;
            } /* Variable */
            code span.vs {
                color: #bf0303;
            } /* VerbatimString */
            code span.wa {
                color: #bf0303;
            } /* Warning */
        </style>
        <!--
  Firefox non carica font da locale quindi il font puÃ² non essere visibile
  quando di carica la pagina da locale.
  Bisogna impostare about:config
    security.fileuri.strict_origin_policy = false
  -->
        <link rel="stylesheet" href="../../inc/css/katex.min.css" />
        <link rel="stylesheet" href="../../inc/css/fonts/google_fonts.css" />
        <!-- <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous"> -->
        <link rel="stylesheet" href="../../inc/css/bootstrap.min.css" />
        <link rel="stylesheet" href="../../inc/css/cdp.css" />
        <!--[if lt IE 9]>
            <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
        <![endif]-->
        <meta name="keywords" content="Appunti,Note" />
        <meta name="description" content="Appunti di runner" />
        <link rel="icon" type="image/x-icon" href="../../inc/img/favicon.ico" />
        <link rel="shortcut icon" type="image/x-icon" href="../../inc/img/favicon.ico" />

        <link rel="stylesheet" href="../../inc/js/hljs/styles/default.css" />
        <script src="../../inc/js/hljs/lib/highlight.js"></script>
        <script src="../../inc/js/bootstrap/bootstrap.bundle.min.js"></script>
        <!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script> -->
        <script>
            hljs.initHighlightingOnLoad();
        </script>
        <script type="module">
            import mermaid from '../../inc/js/mermaid/dist/mermaid.esm.min.mjs';
            // import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
            mermaid.initialize({ startOnLoad: true });
        </script>
    </head>
    <body></body>
</html>
<h1 id="ipc" tabindex="-1">IPC <a class="header-anchor" href="#ipc" aria-hidden="true">ðŸ”—</a></h1>
<p class="code">2025-04-08 13:38:19.894</p>
<nav class="table-of-contents"><ol><li><a href="#ipcs">ipcs </a></li><li><a href="#using-named-pipes-(fifos)-with-bash">Using Named Pipes (FIFOs) with Bash </a></li><li><a href="#pipe-viewer">Pipe Viewer </a></li></ol></nav><h1 id="ipc-1" tabindex="-1">IPC <a class="header-anchor" href="#ipc-1" aria-hidden="true">ðŸ”—</a></h1>
<h2 id="ipcs" tabindex="-1">ipcs <a class="header-anchor" href="#ipcs" aria-hidden="true">ðŸ”—</a></h2>
<p>Quando si esegue il <code>kill -9</code> dei processi Tuxedo possono rimanere appese le risorse IPC.
Per eliminare le risorse IPC dell'ambiente di interesse, bisogna prima cercare il valore della IPCKEY nel $userDIR/Configure.properties,
convertirlo in esadecimale ed usarlo per ricavare gli internal id ipc dall'output del comando ipcs.
Ottenuti gli internal id ipc rimane solamente da utilizzare il comando ipcrm</p>
<pre><code>cd $userDIR
grep IPCKEY Configure.properties
</code></pre>
<p>si trova un numero decimale, es. 40200,
convertirlo in esadecimale perche' la chiave compare in formato esadecimale nell'output di ipcs:</p>
<pre><code class="language-bash">TIFXB_AD user@server5.company.com:/proj/FX_B/userDIR/data/log&gt; ipcs -a|grep 40200 -- NON TROVA NULLA
TIFXB_AD user@server5.company.com:/proj/FX_B/userDIR/data/log&gt; bc
obase = 16
40200
9D08

TIFXB_AD user@server5.company.com:/proj/FX_B/userDIR/data/log&gt; ipcs -a|grep -i 9D08

q 1027727 0x00009d08 --rw-rw-rw- user useradm user useradm 0 0 16384 8303 8043 16:01:22 16:01:22 9:38:59
m 5046294 0x00009d08 --rw-rw-rw- user useradm user useradm 1 11225240 8043 25517 16:13:16 13:45:47 9:38:55
s 434206 0x00009d08 --ra-ra-ra- user useradm user useradm 3 16:54:01 9:38:55

TIFXB_AD user@server5.company.com:/proj/FX_B/userDIR/data/log&gt; ipcrm -q 1027727
TIFXB_AD user@server5.company.com:/proj/FX_B/userDIR/data/log&gt; ipcrm -m 5046294
TIFXB_AD user@server5.company.com:/proj/FX_B/userDIR/data/log&gt; ipcrm -s 434206

ipcs -a
ipcrm (con opzioni -s -q -m) +internal <span class="hljs-built_in">id</span> dato da ipcs
</code></pre>
<pre><code class="language-bash"><span class="hljs-meta">#!/usr/bin/env bash</span>
<span class="hljs-comment"># $Id: cleanIPC,v 2.1 2002/04/25 20:58:24 wcox Exp $</span>
<span class="hljs-comment">#</span>
<span class="hljs-comment"># Check arguments</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">${#}</span> -ne 1 ]; <span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage:&quot;</span> `<span class="hljs-built_in">basename</span> <span class="hljs-variable">${0}</span>` <span class="hljs-string">&quot;&lt;user name&gt;&quot;</span>
<span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>

<span class="hljs-comment">#</span>
<span class="hljs-comment"># do the ditty...</span>
uName=<span class="hljs-variable">${1}</span>
ipcs | egrep <span class="hljs-variable">${uName}</span> | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line; <span class="hljs-keyword">do</span>
kind=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">${line}</span>&quot;</span> | <span class="hljs-built_in">cut</span> -c1-1`
key=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">${line}</span>&quot;</span> | <span class="hljs-built_in">cut</span> -c2-12`
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ipcrm -<span class="hljs-variable">${kind}</span> <span class="hljs-variable">${key}</span>&quot;</span>
ipcrm -<span class="hljs-variable">${kind}</span> <span class="hljs-variable">${key}</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">exit</span> 0
</code></pre>
<h2 id="using-named-pipes-(fifos)-with-bash" tabindex="-1">Using Named Pipes (FIFOs) with Bash <a class="header-anchor" href="#using-named-pipes-(fifos)-with-bash" aria-hidden="true">ðŸ”—</a></h2>
<p>It's hard to write a bash script of much import without using a pipe or two. Named pipes, on the other hand, are much rarer.</p>
<p>Like un-named/anonymous pipes, named pipes provide a form of IPC (Inter-Process Communication). With anonymous pipes, there's one reader and one writer, but that's not required with named pipes?any number of readers and writers may use the pipe.</p>
<p>Named pipes are visible in the filesystem and can be read and written just as other files are:</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">ls</span> -la /tmp/testpipe
prw-r--r-- 1 mitch <span class="hljs-built_in">users</span> 0 2009-03-25 12:06 /tmp/testpipe|
</code></pre>
<p>Why might you want to use a named pipe in a shell script? One situation might be when you've got a backup script that runs via cron, and after it's finished, you want to shut down your system. If you do the shutdown from the backup script, cron never sees the backup script finish, so it never sends out the e-mail containing the output from the backup job. You could do the shutdown via another cron job after the backup is &quot;supposed&quot; to finish, but then you run the risk of shutting down too early every now and then, or you have to make the delay much larger than it needs to be most of the time.</p>
<p>Using a named pipe, you can start the backup and the shutdown cron jobs at the same time and have the shutdown just wait till the backup writes to the named pipe. When the shutdown job reads something from the pipe, it then pauses for a few minutes so the cron e-mail can go out, and then it shuts down the system.</p>
<p>Of course, the previous example probably could be done fairly reliably by simply creating a regular file to signal when the backup has completed. A more complex example might be if you have a backup that wakes up every hour or so and reads a named pipe to see if it should run. You then could write something to the pipe each time you've made a lot of changes to the files you want to back up. You might even write the names of the files that you want backed up to the pipe so the backup doesn't have to check everything.</p>
<p>Named pipes are created via mkfifo or mknod:</p>
<pre><code class="language-bash">$ <span class="hljs-built_in">mkfifo</span> /tmp/testpipe
$ <span class="hljs-built_in">mknod</span> /tmp/testpipe p
</code></pre>
<p>The following shell script reads from a pipe. It first creates the pipe if it doesn't exist, then it reads in a loop till it sees &quot;quit&quot;:</p>
<pre><code class="language-bash"><span class="hljs-meta">#!/usr/bin/env bash</span>
pipe=/tmp/testpipe
<span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;rm -f <span class="hljs-variable">$pipe</span>&quot;</span> EXIT
<span class="hljs-keyword">if</span> [[ ! -p <span class="hljs-variable">$pipe</span> ]]; <span class="hljs-keyword">then</span>
<span class="hljs-built_in">mkfifo</span> <span class="hljs-variable">$pipe</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>
<span class="hljs-keyword">do</span>
<span class="hljs-keyword">if</span> <span class="hljs-built_in">read</span> line &lt;<span class="hljs-variable">$pipe</span>; <span class="hljs-keyword">then</span>
<span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> == <span class="hljs-string">&#x27;quit&#x27;</span> ]]; <span class="hljs-keyword">then</span>
<span class="hljs-built_in">break</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span>
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">echo</span> oops <span class="hljs-comment"># Should not be executed.</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Reader exiting&quot;</span>
</code></pre>
<p>The following shell script writes to the pipe created by the read script. First, it checks to make sure the pipe exists, then it writes to the pipe. If an argument is given to the script, it writes it to the pipe; otherwise, it writes &quot;Hello from PID&quot;.</p>
<pre><code class="language-bash"><span class="hljs-meta">#!/usr/bin/env bash</span>
pipe=/tmp/testpipe
<span class="hljs-keyword">if</span> [[ ! -p <span class="hljs-variable">$pipe</span> ]]; <span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Reader not running&quot;</span>
<span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
<span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> ]]; <span class="hljs-keyword">then</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> &gt;<span class="hljs-variable">$pipe</span>
<span class="hljs-keyword">else</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello from $$&quot;</span> &gt;<span class="hljs-variable">$pipe</span>
<span class="hljs-keyword">fi</span>
</code></pre>
<p>Running the scripts produces:</p>
<pre><code class="language-bash">$ sh rpipe.sh &amp;
[3] 23842
$ sh wpipe.sh
Hello from 23846
$ sh wpipe.sh
Hello from 23847
$ sh wpipe.sh
Hello from 23848
$ sh wpipe.sh quit
Reader exiting
</code></pre>
<p>Note: initially I had the read command in the read script directly in the while loop of the read script, but the read command would usually return a non-zero status after two or three reads causing the loop to terminate.</p>
<pre><code class="language-bash"><span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> line &lt;<span class="hljs-variable">$pipe</span>
<span class="hljs-keyword">do</span>
<span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$line</span>&quot;</span> == <span class="hljs-string">&#x27;quit&#x27;</span> ]]; <span class="hljs-keyword">then</span>
<span class="hljs-built_in">break</span>
<span class="hljs-keyword">fi</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$line</span>
<span class="hljs-keyword">done</span>
</code></pre>
<p>I find named pipes of most use in feeding programs with data from network connections. Just make sure the program does not try to rewind the file.</p>
<pre><code class="language-bash"><span class="hljs-built_in">mkfifo</span> input
programxyz -f input
nc -lvvp 20000 &gt; input
</code></pre>
<p>and on same machine or another send data to port 20000.</p>
<h2 id="pipe-viewer" tabindex="-1">Pipe Viewer <a class="header-anchor" href="#pipe-viewer" aria-hidden="true">ðŸ”—</a></h2>
<p><a href="http://www.ivarch.com/programs/pv.shtml">http://www.ivarch.com/programs/pv.shtml</a></p>
<p>`pv' - Pipe Viewer - is a terminal-based tool for monitoring the progress of data through a pipeline. It can be inserted into any normal pipeline between two processes to give a visual indication of how quickly data is passing through, how long it has taken, how near to completion it is, and an estimate of how long it will be until completion.</p>
<pre><code class="language-bash">apt-get install pv
$ gzip -c access.log &gt; access.log.gz
$ pv access.log | gzip &gt; access.log.gz
611MB 0:00:11 [58.3MB/s] [=&gt; ] 15% ETA 0:00:59
</code></pre>
<p>Pipe viewer acts as &quot;cat&quot; here, except it also adds a progress bar.
We can see that gzip processed 611MB of data in 11 seconds. It has processed 15% of all data and it will take 59 more seconds to finish.</p>
<p>You may stick several pv processes in between. For example, you can time how fast the data is being read from the disk and how much data is gzip outputting:</p>
<pre><code class="language-bash">$ pv -cN <span class="hljs-built_in">source</span> access.log | gzip | pv -cN gzip &gt; access.log.gz
<span class="hljs-built_in">source</span>: 760MB 0:00:15 [37.4MB/s] [=&gt; ] 19% ETA 0:01:02
gzip: 34.5MB 0:00:15 [1.74MB/s] [ &lt;=&gt; ]
</code></pre>
<p>Here we specified the ?-N? parameter to pv to create a named stream. The ?-c? parameter makes sure the output is not garbaged by one pv process writing over the other.</p>
<p>This example shows that ?access.log? file is being read at a speed of 37.4MB/s but gzip is writing data at only 1.74MB/s. We can immediately calculate the compression rate. It?s 37.4/1.74 = 21x!</p>
<pre><code class="language-bash">$ tar -czf - . | pv &gt; out.tgz
117MB 0:00:55 [2.7MB/s] [&gt; ]

$ tar -cf - . | pv -s $(<span class="hljs-built_in">du</span> -sb . | awk <span class="hljs-string">&#x27;{print $1}&#x27;</span>) | gzip &gt; out.tgz
253MB 0:00:05 [46.7MB/s] [&gt; ] 1% ETA 0:04:49
</code></pre>
<p>What happens here is we tell tar to create ?-c? an archive of all files in current dir ?.? (recursively) and output the data to stdout ?-f -?. Next we specify the size ?-s? to pv of all files in current dir. The ?du -sb . | awk ?{print $1}?? returns number of bytes in current dir, and it gets fed as ?-s? parameter to pv. Next we gzip the whole content and output the result to out.tgz file. This way ?pv? knows how much data is still left to be processed and shows us that it will take yet another 4 mins 49 secs to finish.</p>
<pre><code class="language-bash">$ pv /dev/zero &gt; /dev/null
157GB 0:00:38 [4,17GB/s]
</code></pre>
</body></html>